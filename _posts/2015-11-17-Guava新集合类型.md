---
layout: blog
title:  Guava新集合类型
date: 2015-11-17
category: 编程技术
tag: Guava
---
guava的collection包里新增加了几个集合类型非常实用  



*****
## Multiset
`Multiset`继承自`Collection`, 类似于`Set`, 里面的元素是无顺序的, 但不同的是它可以多次添加相等的元素, 并能记录每个元素的个数.
Multiset {a, a, b}和{a, b, a}是相等的, `Multiset`类似于但绝不等同于`Map<E, Integer>`.  
[Collection中的方法]({{ "/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015-11-12-Collection%E6%95%B4%E7%90%86.html" | prepend: site.baseurl }})`Multiset`都有, 注意`size()`方法, 重复的元素也会算个数(类似的其它方法也会包含重复元素)   
除此之外`Multiset`接口中定义的方法有:
* `int count(Object element)`: 返回给定元素的计数
* `int add(E element, int occurrences)`: 添加元素并指定元素个数; 返回添加之前该元素的个数, 一般为0
* `int remove(Object element, int occurrences)`: 移除元素, 若该元素个数小于指定个数,则全移除; 返回操作之前该元素的个数
* `int setCount(E element, int count)`: 设定某一个元素的重复次数, 相当于add和remove的组合体; 返回操作之前该元素的个数
* `boolean setCount(E element, int oldCount, int newCount)`: 将符合原有重复个数的元素修改为新的重复次数, 原来个数不为oldCount不会修改
* `Set<E> elementSet()`: 返回仅包含不同元素的set
* `Set<Entry<E>> entrySet()`: 返回Set<Multiset.Entry>, 包含的Entry支持使用`getElement()`和`getCount()`

*****

## Multiset的各种实现
Multiset的实现类, 可以通过构造方法new出来, 也可以调用`XXXMultiset.create()`静态函数来创建  
它们都直接继承了Multiset接口:

| Guava实现               | 对比JDK的Map       | 是否支持null   |
|------------------------|-------------------|:------------:|
| HashMultiset           | HashMap           |  Y |
| LinkedHashSet          | LinkedHashMap     |  Y |
| TreeMultiset           | TreeMap           |  Y |
| EnumMultiset           | EnumMap           |  N |
| ImmutableMultiset      | ImmutableMap      |  N |
| ConcurrentHashMultiset | ConcurrentHashMap |  N |
| ForwardingMultiset     |                   |    |


*****
## Multimap
`Multimap`把一个键映射到多个值, 类似于但不等同于`Map<K, Collection<V>>`.  
`Multimap`跟JDK中的`Map`并没有什么关系, 但[Map中的方法]({{ "/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015-11-12-Map%E6%95%B4%E7%90%86.html" | prepend: site.baseurl }})在`Multimap`也有对应的  
 `Multimap`接口定义的方法有:

* `int size()`: 返回键值对的个数 `a->1, a->2`算两个
* `boolean isEmpty()`: 是否为空
* `boolean containsKey(Object key)`: 是否包含key
* `boolean containsValue(Object value)`: 是否包含value
* `boolean containsEntry(Object key, Object value)`: 是否包含key-value对
* `boolean put(K key, V value)`: 如果map元素增加了则返回true, 对于允许存在重复键值对的实现类总是返回`true`,
不允许重复键值对存在的实现类才有可能返回`false`
* `boolean putAll(K key, Iterable values)`: map改变则返回true
* `boolean putAll(Multimap multimap)`: map改变则返回true
* `boolean remove(Object key, Object value)`: 移除键值对, map变了返回true
* `Collection<V> removeAll(Object key)`: 移除与key相关的所有values(key也没了), 并返回values组成的集合(可能为空)
* `Collection<V> replaceValues(K key, Iterable values)`: 把与key相关的value全替换掉, 如果values为空,
则等同于`removeAll(key)`, 如果原来不包含key,则相当于`putAll(key, values)`; 返回被替换掉的value集合(可能为空)
* `void clear()`: 清空map
* `Collection<V> get(K key)`: 返回key对应的value, 没有key则返回空集合(不是`null`)

### 视图操作
对这些返回结果的所有操作都会反映到原来的Multimap上
* `Set<K> keySet()`: 返回不重复的key集合
* `Multiset<K> keys()`: 返回可重复的key集合
* `Collection<V> values()`: 返回value的集合, 包含重复值
* `Collection<Map.Entry<K, V>> entries()`: 返回所有键值对,包括重复键
* `Map<K, Collection<V>> asMap()`: 返回`Map<K,Collection<V>>`形式的视图, 返回的Map支持remove操作, 并且会反映到Multimap,
但它不支持put或putAll操作; ListMultimap的`asMap.get(key)`不能直接返回List,
可以使用`Multimaps.asMap.get(key)`来返回具体的集合类型

*****

## Multimap的各种实现
Multimap有许多实现类:

| 实现类                    | 键行为类似            | 值行为类似        | 是否支持null   |
|--------------------------|---------------------|------------------|:------------:|
| LinkedListMultimap       | LinkedHashMap       |  LinkedList      |  Y  |
| ArrayListMultimap        | HashMap             |  ArrayList       |  Y  |
| ImmutableListMultimap    | ImmutableMap        |  ImmutableList   |  N  |
| HashMultimap             | HashMap             |  HashSet         |  Y  |
| LinkedHashMultimap       | LinkedHashMap       |  LinkedHashSet   |  Y  |
| ImmutableSetMultimap     | ImmutableMap        |  ImmutableSet    |  N  |
| TreeMultimap             | TreeMap             |  TreeSet         |  Y  |

其实现类的继承关系图如下:
![Multimap继承关系图]({{ "/static/images/multimap.png"  | prepend: site.baseurl }} "Multimap继承关系图")

*****
