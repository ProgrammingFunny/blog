---
layout: blog
title:  java中的反射
date:   2016-01-14
category: 编程技术
tag: Java
---
java反射总结



*****
## 反射相关的类和接口简介
在`java.lang.reflect`包中定义了一些接口和类,简单记录下他们的作用

### 相关类说明

| 类                    | 说明            |
|-------------------------|---------------------|
| AccessibleObject        | `Field、Method`和`Constructor`对象的基类 |
| Field                   | final类, 对应类或接口的单个字段 |
| Method                  | final类, 对应类或接口的单独某个方法 |
| `Constructor<T>`        | final类, 对应类的单个构造方法 |
| Modifier                | 对应类和成员访问修饰符, 如`public,static,final,native,synchronized`等 |
| Array                   | final类, 对应数组 |
| Proxy                   | 提供用于创建动态代理类和实例的静态方法，它还是由这些方法创建的所有动态代理类的超类 |
| ReflectPermission       | final类, 反射操作的`Permission`类 |
另外反射机制还经常用到`java.lang`中的类, 如`Class`、`Packate`还有各种原始类型等

### 相关接口继承关系图
![反射相关接口继承关系图]({{ "/static/images/reflect_interface.png"  | prepend: site.baseurl }} "反射相关接口继承关系图")
### 相关接口说明

| 接口                    | 说明            |
|-------------------------|---------------------|
| AnnotatedElement        | 被注解标注的元素都实现的接口<br> 实现类有`AccessibleObject`及其子类,`Class``Package`<br> 有`是否有注解`,`获取所有注解`等方法 |
| Member                  | 成员接口, 反映字段、方法、构造函数的信息<br> 实现类有`AccessibleObject`的子类 |
| Type                    | 所有类型的父接口, 如原始类型、参数化类型、数组类型、类型变量和基本(原生)类型 |
| GenericDeclaration      | 各种声明类型的父接口, 如`Class,Constructor,Method` |
| `TypeVariable<D extends GenericDeclaration>` | 各种类型变量的父接口 |
| ParameterizedType       | 参数化类型, 如`Collection<String>`  |
| GenericArrayType        | 数组类型, 它里面的元素为参数化类型或类型变量(上面那俩)  |
| WildcardType            | 通配符类型, 如`<?>, <? extends Number>, <? super Integer>`|
| InvocationHandler       | 代理实例的调用处理程序需要实现该接口<br> `Proxy`是代理实例,它的处理程序需要实现该接口的`invoke`方法 |

*****
## `Object`, `Class`和`Type`的关系和区别
所有的类都继承`Object`是毫无疑问的, `Class`也是类，也继承`Object`  
`Class`类特殊的地方是它在运行时用来描述类的各种元信息,对象是类的实例,而类在运行时的描述就是`Class`  
`Type`是个接口,用来表示某个对象是什么类型的,`Class`类实现了好几个接口,其中一个就是`Type`


*****
## 反射的具体功能
反射作用挺多, 比如反编译, 通过反射机制访问对象的属性、方法、构造方法等
### 获取类
有如下三种方法:
1. 通过`Class.forName()`, 如:`Class clazz = Class.forName("java.lang.String");`
2. 通过类的`class`属性, 如:`Class clazz = String.class;`
3. 通过实例对象的`getClass`方法, 如: `Class clazz = user.getClass();`

### 获取对象实例
1. 通过`Class`实例的`newInstance()`, 如:`String str = (String)clazz.newInstance();`

### 获取构造方法
1. `Constructor<?>[] getConstructors()`: 获取本类中所有public构造器
2. `Constructor<T> getConstructor(Class<?>... parameterTypes)`: 获取本类中特定参数的public构造器
3. `Constructor<?>[] getDeclaredConstructors()`: 获取本类中所有构造器
4. `Constructor<T> getDeclaredConstructor(Class<?>... parameterTypes)`: 获取本类中指定参数的构造器

### 获取类方法
1. `Method[] getMethods()`: 获取本类或父类中所有public方法(包括构造器方法)
2. `Method getMethod(String name, Class<?>... parameterTypes)`: 获取本类或父类中特定名字和参数的public方法
3. `Method[] getDeclaredMethods()`: 获取本类中声明的所有方法(包括非public但不包括继承来的)
4. `Method getDeclaredMethod(String name, Class<?>... parameterTypes)`: 获取本类中声明的特定名字和参数的方法(最常用)

### 获取类属性
1. `Field[] getFields()`: 获取本类或父类中所有public属性
2. `Field getField(String name)`: 获取本类或父类中特定名字的public属性
3. `Field[] getDeclaredFields()`: 获取本类中声明的所有属性
4. `Field getDeclaredField(String name)`: 获取本类中声明的特定名字的属性

*****
## 通过反射实现方法动态调用的例子

```java
public class Test {
    private String name;
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    public static void main(String[] args) throws Exception {
        Object obj = Test.class.newInstance();
        Test.class.getDeclaredMethod("setName", String.class).invoke(obj, "Tom");
        Method getNameMethod = Test.class.getDeclaredMethod("getName");
        String name = (String) getNameMethod.invoke(obj);
        System.out.println(name);
    }
}
```

*****
