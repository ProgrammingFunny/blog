<!DOCTYPE html>
<html>

  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="description" content="Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.
">

    <!-- <title>About</title> -->
    <title>Michael King's Blog</title>

    <script src="/blog/assets/js/scale.fix.js"></script>
    <link rel="stylesheet" href="/blog/assets/css/styles.css">
    <link rel="stylesheet" href="/blog/assets/css/pygment_trac.css">
    <link rel="canonical" href="http://yourdomain.com/blog/about/">
    <link rel="alternate" type="application/rss+xml" title="Michael King's Blog" href="http://yourdomain.com/blog/feed.xml" />

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
</head>

  <body>
    <div class="page">

      <!-- 头部 -->
      <header>
  <h1> <a href="/blog">Michael King's Blog</a> </h1>
  <p>水到绝境是飞瀑</p>
  <ul>
      <li><a href="https://github.com//blog/tree/gh-pages">View On <strong>GitHub</strong></a></li>
      <li><a href="https://github.com//blog/tree/gh-pages">View On <strong>GitHub</strong></a></li>
      <li><a href="https://github.com//blog/tree/gh-pages">View On <strong>GitHub</strong></a></li>
  </ul>
</header>
      <!-- 侧边栏 -->
      <aside>
    <h1 style="margin:auto 0;"> 目录分类 </h1>
    
        <a style="display: block; " href="/blog/markdown "> markdown (1) </a>
        <p>markdown<p>Markdown是用于书写纯文本文件的语言，通过一些特殊标记使文本更加容易读，而且兼容HTML。<br>
如果想看本文的例子，可以将代码块中的文字复制到<a href="http://tool.oschina.net/markdown/">在线 Markdown 编译器</a>来查看效果<br>
本文是我在使用Markdown时所作的总结，更详细的Markdown语法请看<a href="http://wowubuntu.com/markdown/basic.html">Markdown 语法说明 (简体中文版)</a>  </p>

<hr>

<h2>本文结构</h2>

<ul>
<li><a href="#anchor1">标题</a></li>
<li><a href="#anchor2">分割线</a></li>
<li><a href="#anchor3">代码</a></li>
<li><a href="#anchor4">引用</a></li>
<li><a href="#anchor5">列表</a></li>
<li><a href="#anchor6">链接</a></li>
<li><a href="#anchor7">强调</a></li>
<li><a href="#anchor8">图片</a></li>
<li><a href="#anchor9">自动链接</a></li>
</ul>

<hr>

<h2 id="anchor1"> 标题 </h2>
<div class="highlight"><pre><code class="language-text" data-lang="text">这样表示H1
=========

# 这也可以表示H1

这表示H2
-------

## 这也是H2 ##

### H3 后面放几个`#`都无所谓

#### H4 H1~H6 都可以用`#`方式来表达
</code></pre></div>
<hr>

<h2 id="anchor2"> 分割线 </h2>

<p>一行中用三个以上的星号、减号、底线都能建立一个分隔线，行内可以有空格，但不能有其他东西。如下均可以：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">* * *  
***
*****
- - -
----------------------------------------
______
</code></pre></div>
<hr>

<h2>段落和换行</h2>

<p>文字前后要有一个以上的空行才会产生段落，文本中的换行并不会产生换行符<code>&lt;br /&gt;</code>，如果要强制产生换行符<code>&lt;br /&gt;</code>的话，可以在行末尾加两个空格。如下：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">这样是不产
生换行的

如果在末尾加两个空格  
就会强制换行
</code></pre></div>
<hr>

<h2 id="anchor3"> 代码 </h2>

<p>代码分为行内的代码(如<code>printf()</code>)和代码块，建立代码块需要将代码块缩紧4个空格或一个tab键，行内代码可通过反引号<code>`</code>实现。如下：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">这是普通段落

    这是代码块

这是行内代码`printf()`

如果行内代码本身包含反引号，可以使用多个反引号来开启和关闭代码块，  
如：`` `foo` ``，为了能正确表示一开始就有反引号的情况，中间的内容要用空格隔开。
</code></pre></div>
<hr>

<h2 id="anchor4"> 引用 </h2>

<p>在行首添加<code>&gt;</code>表示引用，如下：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">&gt; 行首加引用
&gt; 
&gt; 也可以偷懒，只在每
一段的开头加一个也可以
&gt;
&gt; 还能嵌套引用 
&gt; 
&gt; &gt; 嵌套引用  
&gt;
&gt; ### 里面还能写其他的markdown语法
&gt;
&gt;     printf(&quot;代码区块也可以&quot;);
</code></pre></div>
<hr>

<h2 id="anchor5"> 列表 </h2>

<p>Markdown 支持有序列表和无序列表，无需列表会转换成html中的<code>&lt;ul&gt;</code>，有序列表会转换成html中的<code>&lt;ol&gt;</code>。</p>

<p>无序列表使用星号、加号或是减号作为列表标记，标记与内容间至少有一个空格，如：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">*   Red
*   Green
+   Blue
-   Yello
</code></pre></div>
<p>有序列表则使用数字接着一个英文句点，如：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">1.  Bird
2.  McHale
3.  Parish
9.  数字的序号是无所谓的
</code></pre></div>
<hr>

<h2 id="anchor6"> 链接 </h2>

<p>链接语法包括行内式和参考式两种形式<br>
行内式的链接，链接文字都是用 [方括号] 来标记， 如：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">这是个链接[百度](http://www.baidu.com #maodian)
这是个链接[百度](http://www.baidu.com &quot;Title&quot;)
</code></pre></div>
<p>参考式是在链接文字的括号后面再接上另一个方括号，而在第二个方括号里填入用以辨识链接的标记(不区分大小写)，如：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">这是[百度][1]  
这是[谷歌][2]

[1]: http://www.baidu.com &quot;Optional Title Here&quot;
[2]: http://www.google.com &quot;Optional Title Here&quot;
</code></pre></div>
<p>其内容定义的形式为：</p>

<ul>
<li> 方括号（前面可以选择性地加上至多三个空格来缩进），里面输入链接文字</li>
<li> 接着一个冒号</li>
<li> 接着一个以上的空格或制表符</li>
<li> 接着链接的网址</li>
<li> 选择性地接着 title 内容，可以用双引号或是括弧包着</li>
</ul>

<hr>

<h2 id="anchor7"> 强调 </h2>

<p>Markdown 使用星号（<code>*</code>）和底线（<code>_</code>）作为标记强调字词的符号，被 <code>*</code> 或 <code>_</code> 包围的字词会被转成用 <code>&lt;em&gt;</code> 标签包围，
用两个 <code>*</code> 或 <code>_</code> 包起来的话，则会被转成 <code>&lt;strong&gt;</code>。<br>
如果 <code>*</code> 和 <code>_</code> 两边都有空白的话，它们就只会被当成普通符号。<br>
如果要在文字前后直接插入普通的星号或底线，就需要用反斜线来转义。</p>

<hr>

<h2 id="anchor8"> 图片 </h2>

<p>图片跟链接很类似，同样分为行内式和参考式。只是比链接前面多了一个<code>!</code>，如：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">![Alt text](/path/to/img.jpg &quot;Optional title&quot;)
</code></pre></div>
<hr>

<h2 id="anchor9"> 自动链接 </h2>

<p>Markdown 支持以比较简短的自动链接形式来处理<strong>网址</strong>和<strong>电子邮箱</strong>，只要用尖括号包起来。</p>

<p>网址的链接文字就和链接地址一样，例如：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">&lt;http://example.com/&gt;
</code></pre></div>
<p>Markdown 会转为：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">&lt;a href=&quot;http://example.com/&quot;&gt;http://example.com/&lt;/a&gt;
</code></pre></div>
<p>邮件的自动链接也很类似，只是 Markdown 会先做一个编码转换的过程，把文字字符转成 16 进位码的 HTML 实体，这样的格式可以糊弄一些不好的邮址收集机器人，例如：</p>

<p><a href="mailto:address@example.com">address@example.com</a></p>

<p>Markdown 会转成：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">&lt;a href=&quot;&amp;#x6D;&amp;#x61;i&amp;#x6C;&amp;#x74;&amp;#x6F;:&amp;#x61;&amp;#x64;&amp;#x64;&amp;#x72;&amp;#x65;
&amp;#115;&amp;#115;&amp;#64;&amp;#101;&amp;#120;&amp;#x61;&amp;#109;&amp;#x70;&amp;#x6C;e&amp;#x2E;&amp;#99;&amp;#111;
&amp;#109;&quot;&gt;&amp;#x61;&amp;#x64;&amp;#x64;&amp;#x72;&amp;#x65;&amp;#115;&amp;#115;&amp;#64;&amp;#101;&amp;#120;&amp;#x61;
&amp;#109;&amp;#x70;&amp;#x6C;e&amp;#x2E;&amp;#99;&amp;#111;&amp;#109;&lt;/a&gt;
</code></pre></div>
<p>这段字（其实是 <code>&lt;a href=&quot;mailto:address@example.com&quot;&gt;address@example.com&lt;/a&gt;</code>) 会变成一个可以点击的「address@example.com」链接。
貌似邮件自动链接在开始提到的<a href="http://tool.oschina.net/markdown/">在线 Markdown 编译器</a>中不起作用</p>

<hr>
</p>
    
        <a style="display: block; " href="/blog/info "> info (1) </a>
        <p>info<p>You’ll find this post in your <code>_posts</code> directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run <code>jekyll serve</code>, which launches a web server and auto-regenerates your site when a file is updated.</p>

<p>To add new posts, simply add a file in the <code>_posts</code> directory that follows the convention <code>YYYY-MM-DD-name-of-post.ext</code> and includes the necessary front matter. Take a look at the source for this post to get an idea about how it works.</p>

<p>Jekyll also offers powerful support for code snippets:</p>

<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">def</span> <span class="nf">print_hi</span><span class="p">(</span><span class="nb">name</span><span class="p">)</span>
  <span class="nb">puts</span> <span class="s2">&quot;Hi, </span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="s2">&quot;</span>
<span class="k">end</span>
<span class="n">print_hi</span><span class="p">(</span><span class="s1">&#39;Tom&#39;</span><span class="p">)</span>
<span class="c1">#=&gt; prints &#39;Hi, Tom&#39; to STDOUT.</span></code></pre></div>

<p>Check out the <a href="http://jekyllrb.com">Jekyll docs</a> for more info on how to get the most out of Jekyll. File all bugs/feature requests at <a href="https://github.com/jekyll/jekyll">Jekyll’s GitHub repo</a>. If you have questions, you can ask them on <a href="https://github.com/jekyll/jekyll-help">Jekyll’s dedicated Help repository</a>.</p>
</p>
    
        <a style="display: block; " href="/blog/java "> java (1) </a>
        <p>java<h2>如何创建一个线程</h2>

<p>按 Java 语言规范中的说法，创建线程只有一种方式，就是创建一个 Thread 对象。而从 HotSpot 虚拟机的角度看，创建一个虚拟机线程
有两种方式，一种是创建 Thread 对象，另一种是创建 一个本地线程，加入到虚拟机线程中。</p>

<p>如果从 Java 语法的角度。有两种方法。</p>

<p>第一是继承 Thread 类，实现 run 方法，并创建子类对象。</p>
<div class="highlight"><pre><code class="language-java" data-lang="java">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">startThreadUseSubClass</span><span class="o">()</span> <span class="o">{</span>
        <span class="kd">class</span> <span class="nc">MyThread</span> <span class="kd">extends</span> <span class="n">Thread</span> <span class="o">{</span>
            <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
                <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;start thread using Subclass of Thread&quot;</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="n">MyThread</span> <span class="n">thread</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">MyThread</span><span class="o">();</span>
        <span class="n">thread</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
    <span class="o">}</span>
</code></pre></div>
<p>另一种是传递给 Thread 构造函数一个 Runnable 对象。</p>
<div class="highlight"><pre><code class="language-java" data-lang="java">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">startThreadUseRunnalbe</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">Thread</span> <span class="n">thread</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">Thread</span><span class="o">(</span><span class="k">new</span> <span class="nf">Runnable</span><span class="o">()</span> <span class="o">{</span>
            <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
                <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;start thread using runnable&quot;</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">});</span>
        <span class="n">thread</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
    <span class="o">}</span>
</code></pre></div>
<p>当然， Runnalbe 对象，也不是只有这一种形式，例如如果我们想要线程执行时返回一个值，就需要用到另一种 Runnalbe 对象，它
对原来的 Runnalbe 对象进行了包装。</p>
<div class="highlight"><pre><code class="language-java" data-lang="java">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">startFutureTask</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">FutureTask</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">task</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FutureTask</span><span class="o">&lt;&gt;(</span><span class="k">new</span> <span class="n">Callable</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;()</span> <span class="o">{</span>
            <span class="kd">public</span> <span class="n">Integer</span> <span class="nf">call</span><span class="o">()</span> <span class="o">{</span>
                <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">});</span>

        <span class="k">new</span> <span class="nf">Thread</span><span class="o">(</span><span class="n">task</span><span class="o">).</span><span class="na">start</span><span class="o">();</span>

        <span class="k">try</span> <span class="o">{</span>
            <span class="n">Integer</span> <span class="n">result</span> <span class="o">=</span> <span class="n">task</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;future result &quot;</span> <span class="o">+</span> <span class="n">result</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">ExecutionException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
</code></pre></div>
<h2>结束线程</h2>

<h2>wait 与 sleep</h2>

<p>sleep 会使得当前线程休眠一段时间，但并不会释放已经得到的锁。</p>

<p>wait 会阻塞住，并释放已经得到的锁。一直到有人调用 notify 或者 notifyAll，它会重新尝试得到锁，然后再唤醒。</p>

<h2>线程池</h2>

<h3>好处</h3>

<ul>
<li>复用</li>
</ul>

<p>线程池中有一系列线程，这些线程在执行完任务后，并不会被销毁，而会从任务队列中取出任务，执行这些任务。这样，就避免为每个任务
都创建线程，销毁线程。 在有大量短命线程的场景下，如果创建线程和销毁线程的时间比线程执行任务的时间还长，显然是不划算的，这时候，使用线程池就会有明显
的好处。</p>

<ul>
<li>流控</li>
</ul>

<p>同时，可以设置线程数目，这样，线程不会增大到影响系统整体性能的程度。当任务太多时，可以在队列中排队，
如果有空闲线程，他们会从队列中取出任务执行。</p>

<h3>使用</h3>

<ul>
<li>线程数目</li>
</ul>

<p>那么，线程的数目要设置成多少呢？这需要根据任务类型的不同来设置，假如是大量计算型的任务，他们不会阻塞，那么可以将线程数目设置
为处理器数目。而如果任务中涉及大量IO，有些线程会阻塞住，这样就要根据阻塞线程数目与运行线程数目的比例，以及处理器数目来设置
线程总数目。例如阻塞线程数目与运行线程数目之比为n, 处理器数目为p，那么可以设置 n * (p + 1) 个线程，保证有 n 个线程处于运行
状态。</p>

<ul>
<li>Executors</li>
</ul>

<p>JDK 的 java.util.concurrent.Executors 类提供了几个静态的方法，用于创建不同类型的线程池。</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">ExecutorService</span> <span class="n">service</span> <span class="o">=</span> <span class="n">Executors</span><span class="o">.</span><span class="na">newFixedThreadPool</span><span class="o">(</span><span class="mi">10</span><span class="o">);</span>
<span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Future</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;&gt;</span> <span class="n">results</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">14</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
    <span class="n">Future</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">r</span> <span class="o">=</span> <span class="n">service</span><span class="o">.</span><span class="na">submit</span><span class="o">(</span><span class="k">new</span> <span class="n">Callable</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;()</span> <span class="o">{</span>
        <span class="kd">public</span> <span class="n">Integer</span> <span class="nf">call</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">Random</span><span class="o">().</span><span class="na">nextInt</span><span class="o">();</span>
    <span class="o">});</span>
    <span class="n">results</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">r</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div>
<p><code>newFixedThreadPool</code> 可以创建固定数目的线程，一旦创建不会自动销毁线程，即便长期没有任务。除非显式关闭线程池。如果任务队列中有任务，就取出任务执行。</p>

<p>另外，还可以使用 <code>newCachedThreadPool</code> 方法创建一个不设定固定线程数目的线程池，它有一个特性，线程完成任务后，如果一分钟之内又有新任务，就会复用这个线程执行新任务。如果超过一分钟还没有任务执行，就会自动销毁。</p>

<p>另外，还提供了 <code>newSingleThreadExecutor</code> 创建有一个工作线程的线程池。</p>

<h3>原理</h3>

<p>JDK 中的线程池通过 HashSet 存储工作者线程，通过 BlockingQueue 来存储待处理任务。</p>

<p>通过核心工作者数目(corePoolSize) 和 最大工作者数目(maximumPoolSize) 来确定如何处理任务。如果当前工作者线程数目
小于核心工作者数目，则创建一个工作者线程执行这个任务。否则，将这个任务放入待处理队列。如果入队失败，再看看当前工作
者数目是不是小于最大工作者数目，如果小于，则创建工作者线程执行这个任务。否则，拒绝执行这个任务。</p>

<p>另外，如果待处理队列中没有任务要处理，并且工作者线程数目超过了核心工作者数目，那么，需要减少工作者线程数目。</p>
</p>
    
</aside>

      <!-- 内容主体 -->
      <div class="wrapper">
        <!-- 文章内容 -->
        <section>
          <h1> About </h1>
          <p>This is the base Jekyll theme. You can find out more info about customizing your Jekyll theme, as well as basic Jekyll usage documentation at <a href="http://jekyllrb.com/">jekyllrb.com</a></p>

<p>You can find the source code for the Jekyll new theme at: <a href="https://github.com/jglovier/jekyll-new">github.com/jglovier/jekyll-new</a></p>

<p>You can find the source code for Jekyll at <a href="https://github.com/jekyll/jekyll">github.com/jekyll/jekyll</a></p>

        </section>
      </div>

      <footer>
  <p>Project maintained by <a href="https://github.com/"></a></p>
  <p>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></p>
</footer>
<!--[if !IE]><script>fixScale(document);</script><![endif]-->
  </page>
  </body>

</html>
